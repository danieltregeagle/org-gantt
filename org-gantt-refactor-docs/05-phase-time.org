#+TITLE: Phase 4: Extract Time Module
#+PROPERTY: PHASE 4
#+PROPERTY: RISK Medium
#+PROPERTY: SESSIONS 2

* Objective

Extract all time-related functions to =org-gantt-time.el=. This is a medium-risk
phase because functions need signature changes to accept configuration as
parameters instead of reading from globals.

* Key Challenge

The original functions use global state:
- =(org-gantt-hours-per-day)= reads =org-gantt-hours-per-day-gv=
- Many functions read =org-gantt-options= for =:work-free-days=

The refactored functions will accept these as explicit parameters.

* Prompt for Claude Code (Session 1 of 2)

#+begin_src markdown
## Task: Extract Time Functions to org-gantt-time.el (Part 1)

Create `org-gantt-time.el` containing time calculation functions. This is the
first session focusing on simpler functions.

### Critical Refactoring Pattern:

Functions that currently use globals must accept parameters instead.

**Before (uses global):**
```elisp
(defun org-gantt-hours-per-day ()
  "Get the hours per day."
  org-gantt-hours-per-day-gv)

(defun org-gantt-is-workday (time)
  "Return non-nil, iff TIME is a workday."
  (let ((dow (string-to-number (format-time-string "%w" time)))
        (work-free-days (plist-get org-gantt-options :work-free-days)))
    (not (member dow work-free-days))))
```

**After (pure function with parameters):**
```elisp
(defun org-gantt-time-is-workday (time work-free-days)
  "Return non-nil if TIME is a workday.
WORK-FREE-DAYS is a list of day-of-week numbers (0=Sunday, 6=Saturday)."
  (let ((dow (string-to-number (format-time-string "%w" time))))
    (not (member dow work-free-days))))
```

### Functions to Extract in This Session:

**Group 1: Simple time accessors and converters**

1. `org-gantt-hours-per-day` → DELETE (will be context field access)
2. `org-gantt-hours-per-day-time` → `org-gantt-time-hours-to-time`
   - Change: Accept hours-per-day as parameter

3. `org-gantt-timestamp-to-time` (line ~491) → `org-gantt-time-from-timestamp`
   - No change needed (doesn't use globals)

4. `org-gantt-strings-to-time` (line ~517) → `org-gantt-time-from-strings`
   - Change: Accept hours-per-day as parameter (currently reads from global)
   - Also reads work-free-days for week calculation

5. `org-gantt-effort-to-time` (line ~543) → `org-gantt-time-from-effort`
   - Change: Accept hours-per-day as explicit parameter

**Group 2: Workday calculations**

6. `org-gantt-is-workday` (line ~565) → `org-gantt-time-is-workday`
   - Change: Accept work-free-days as parameter

7. `org-gantt-change-workdays` (line ~571) → `org-gantt-time-change-workdays`
   - Change: Accept work-free-days as parameter

8. `org-gantt-day-end` (line ~585) → `org-gantt-time-day-end`
   - Change: Accept hours-per-day as parameter

9. `org-gantt-day-start` (line ~591) → `org-gantt-time-day-start`
   - No change needed (doesn't use globals)

### File Structure:

```elisp
;;; org-gantt-time.el --- Time calculations for org-gantt -*- lexical-binding: t -*-

;; Copyright (C) 2025 [Author]

;;; Commentary:
;;
;; Time and date calculation functions for org-gantt. All functions
;; in this module are pure - they accept configuration as explicit
;; parameters rather than reading from global state.
;;
;; Key concepts:
;; - hours-per-day: Working hours in a day (typically 8)
;; - work-free-days: List of day-of-week numbers (0=Sun, 6=Sat)
;; - worktime: Time that accounts for non-working days

;;; Code:

(require 'cl-lib)
(require 'calendar)
(require 'org-gantt-config)
(require 'org-gantt-util)

;;; Time Conversion

(defun org-gantt-time-hours-to-time (hours-per-day)
  "Convert HOURS-PER-DAY to an Emacs time value."
  (seconds-to-time (* 3600 hours-per-day)))

(defun org-gantt-time-from-timestamp (timestamp &optional use-end)
  "Convert org TIMESTAMP to Emacs time.
If USE-END is non-nil, use the end values of a timestamp range."
  ;; [Copy implementation from org-gantt-timestamp-to-time]
  ...)

(defun org-gantt-time-from-effort (effort &optional hours-per-day)
  "Parse EFFORT string and return as Emacs time.
EFFORT is a string like \"2d 4:00\" or \"1w\".
HOURS-PER-DAY defaults to 8 if not specified."
  ;; [Adapted from org-gantt-effort-to-time]
  ...)

;;; Workday Calculations

(defun org-gantt-time-is-workday (time work-free-days)
  "Return non-nil if TIME is a workday.
WORK-FREE-DAYS is a list of day-of-week numbers (0=Sunday, 6=Saturday).
Does not consider holidays."
  ...)

(defun org-gantt-time-day-start (time)
  "Return the start of the day containing TIME (midnight)."
  ...)

(defun org-gantt-time-day-end (time hours-per-day)
  "Return the end of the workday containing TIME.
HOURS-PER-DAY specifies the workday length."
  ...)

(defun org-gantt-time-change-workdays (time ndays change-fn work-free-days)
  "Add or subtract NDAYS workdays to TIME.
CHANGE-FN is `time-add' or `time-subtract'.
WORK-FREE-DAYS defines non-working days.
Returns the resulting time."
  ...)

(provide 'org-gantt-time)
;;; org-gantt-time.el ends here
```

### Important Notes:

1. Include the original line numbers as comments for traceability
2. Preserve ALL docstrings but update them for new signatures
3. Use lexical-binding: t
4. Functions should be pure - no side effects, no global access
5. Add assertions for invalid inputs where appropriate
#+end_src

* Prompt for Claude Code (Session 2 of 2)

#+begin_src markdown
## Task: Extract Time Functions to org-gantt-time.el (Part 2)

Continue adding complex time arithmetic functions to `org-gantt-time.el`.

### Functions to Add:

**Group 3: Complex time arithmetic**

10. `org-gantt-add-worktime` (line ~597) → `org-gantt-time-add-worktime`
    - Change: Accept hours-per-day and work-free-days as parameters
    - This is a complex function - preserve logic carefully

11. `org-gantt-change-worktime` (line ~630) → `org-gantt-time-change-worktime`
    - Change: Accept hours-per-day and work-free-days as parameters
    - Generic add/subtract function

12. `org-gantt-get-next-time` (line ~656) → `org-gantt-time-next-start`
    - Change: Accept hours-per-day and work-free-days
    - Get time where next task should start

13. `org-gantt-get-prev-time` (line ~671) → `org-gantt-time-prev-end`
    - Change: Accept hours-per-day and work-free-days
    - Get time where previous task should end

**Group 4: Time normalization**

14. `org-gantt-downcast-endtime` (line ~957) → `org-gantt-time-downcast-end`
    - Change: Accept hours-per-day and work-free-days

15. `org-gantt-upcast-starttime` (line ~970) → `org-gantt-time-upcast-start`
    - Change: Accept hours-per-day and work-free-days

**Group 5: Ratio calculations (for rendering)**

16. `org-gantt-get-day-ratio` (line ~983) → `org-gantt-time-day-ratio`
    - Change: Accept hours-per-day as parameter

17. `org-gantt-get-month-ratio` (line ~994) → `org-gantt-time-month-ratio`
    - No change needed (doesn't use globals)

### Implementation Notes for Complex Functions:

**org-gantt-time-add-worktime:**
This function adds work time to a timestamp, handling:
- Crossing day boundaries
- Skipping non-work days (weekends)
- Hours-per-day limits

Key logic to preserve:
1. If change fits in current day's remaining time, just add
2. Otherwise, advance to next workday and continue
3. Loop until all work time is consumed

```elisp
(defun org-gantt-time-add-worktime (time change-time hours-per-day work-free-days)
  "Add CHANGE-TIME work time to TIME.
Respects HOURS-PER-DAY and WORK-FREE-DAYS.
Returns the new time after adding work time."
  (let* ((day-end (org-gantt-time-day-end time hours-per-day))
         (rest-time (time-subtract day-end time))
         (one-day (days-to-time 1)))
    (if (time-less-p change-time rest-time)
        ;; Change fits in current day
        (time-add time change-time)
      ;; Need to span multiple days
      (let* ((next-day-decoded 
              (decode-time 
               (org-gantt-time-change-workdays time 1 #'time-add work-free-days)))
             (next-day (encode-time 0 0 0 
                                   (nth 3 next-day-decoded)
                                   (nth 4 next-day-decoded) 
                                   (nth 5 next-day-decoded)))
             (rest-change (time-subtract change-time rest-time))
             (rest-sec (round (time-to-seconds rest-change))))
        ;; Consume full working days
        (while (> rest-sec (* 3600 hours-per-day))
          (setq next-day 
                (org-gantt-time-change-workdays next-day 1 #'time-add work-free-days))
          (setq rest-change 
                (time-subtract rest-change 
                              (seconds-to-time (* 3600 hours-per-day))))
          (setq rest-sec (round (time-to-seconds rest-change))))
        ;; Add remaining time to final day
        (time-add next-day rest-change)))))
```

### After Both Sessions:

Update org-gantt.el to:
1. Add `(require 'org-gantt-time)` 
2. Create compatibility wrappers that call the new functions with values
   from global state (temporary, until globals are eliminated)

Example wrapper:
```elisp
(defun org-gantt-is-workday (time)
  "Deprecated: Use `org-gantt-time-is-workday' with explicit parameters."
  (org-gantt-time-is-workday 
   time 
   (plist-get org-gantt-options :work-free-days)))
```
#+end_src

* Verification Steps

** Step 1: Verify file exists and has all functions

#+begin_src bash
test -f org-gantt-time.el && echo "File exists" || echo "MISSING"
grep -c "^(defun org-gantt-time-" org-gantt-time.el
#+end_src

Expected: File exists, 15+ functions

** Step 2: Verify no global state access

#+begin_src bash
grep -E "org-gantt-options|org-gant-hours-per-day-gv|\*org-gantt-" org-gantt-time.el
#+end_src

Expected: No matches

** Step 3: Byte-compile

#+begin_src bash
emacs -batch -L . -f batch-byte-compile org-gantt-time.el
#+end_src

Expected: No errors or warnings

** Step 4: Run unit tests

#+begin_src bash
emacs -batch -L . -L test -l ert \
      -l test/org-gantt-time-test.el \
      -f ert-run-tests-batch-and-exit
#+end_src

** Step 5: Regression test

#+begin_src bash
make regression
#+end_src

* Test File: test/org-gantt-time-test.el

#+begin_src emacs-lisp
;;; org-gantt-time-test.el --- Tests for org-gantt-time -*- lexical-binding: t -*-

;;; Code:

(require 'ert)
(require 'org-gantt-time)

(defvar test-work-free-days '(0 6)
  "Standard weekend: Sunday (0) and Saturday (6).")

(defvar test-hours-per-day 8
  "Standard 8-hour workday.")

;;; Time Conversion Tests

(ert-deftest org-gantt-time-test-hours-to-time ()
  "Test converting hours to time value."
  (should (= (* 8 3600) 
             (time-to-seconds (org-gantt-time-hours-to-time 8))))
  (should (= (* 6 3600)
             (time-to-seconds (org-gantt-time-hours-to-time 6)))))

(ert-deftest org-gantt-time-test-from-timestamp ()
  "Test timestamp parsing."
  ;; This would need actual org-element timestamp objects
  ;; Placeholder for real test
  (should t))

(ert-deftest org-gantt-time-test-from-effort-days ()
  "Test effort parsing for days."
  (let ((effort-2d (org-gantt-time-from-effort "2d" 8)))
    (should effort-2d)
    (should (= (* 2 8 3600) (time-to-seconds effort-2d)))))

(ert-deftest org-gantt-time-test-from-effort-hours ()
  "Test effort parsing for hours:minutes."
  (let ((effort-4h (org-gantt-time-from-effort "4:00" 8)))
    (should effort-4h)
    (should (= (* 4 3600) (time-to-seconds effort-4h)))))

(ert-deftest org-gantt-time-test-from-effort-complex ()
  "Test effort parsing for complex values."
  (let ((effort (org-gantt-time-from-effort "1d 4:30" 8)))
    (should effort)
    ;; 1 day (8h) + 4.5 hours = 12.5 hours
    (should (= (* 12.5 3600) (time-to-seconds effort)))))

;;; Workday Calculation Tests

(ert-deftest org-gantt-time-test-is-workday ()
  "Test workday detection."
  ;; Monday Jan 6, 2025
  (let ((monday (encode-time 0 0 12 6 1 2025)))
    (should (org-gantt-time-is-workday monday test-work-free-days)))
  ;; Saturday Jan 11, 2025  
  (let ((saturday (encode-time 0 0 12 11 1 2025)))
    (should-not (org-gantt-time-is-workday saturday test-work-free-days)))
  ;; Sunday Jan 12, 2025
  (let ((sunday (encode-time 0 0 12 12 1 2025)))
    (should-not (org-gantt-time-is-workday sunday test-work-free-days))))

(ert-deftest org-gantt-time-test-day-start ()
  "Test getting day start."
  (let* ((time (encode-time 30 45 14 6 1 2025))  ; 2:45:30 PM
         (start (org-gantt-time-day-start time))
         (decoded (decode-time start)))
    (should (= 0 (nth 0 decoded)))  ; seconds
    (should (= 0 (nth 1 decoded)))  ; minutes  
    (should (= 0 (nth 2 decoded)))  ; hours
    (should (= 6 (nth 3 decoded)))  ; day unchanged
    (should (= 1 (nth 4 decoded)))  ; month unchanged
    (should (= 2025 (nth 5 decoded)))))  ; year unchanged

(ert-deftest org-gantt-time-test-day-end ()
  "Test getting day end."
  (let* ((time (encode-time 0 30 14 6 1 2025))  ; 2:30 PM
         (end (org-gantt-time-day-end time 8))
         (decoded (decode-time end)))
    (should (= 0 (nth 0 decoded)))  ; seconds
    (should (= 0 (nth 1 decoded)))  ; minutes
    (should (= 8 (nth 2 decoded)))  ; 8 AM (hours-per-day)
    (should (= 6 (nth 3 decoded))))) ; same day

(ert-deftest org-gantt-time-test-change-workdays-add ()
  "Test adding workdays."
  ;; Start on Monday Jan 6, add 4 workdays = Friday Jan 10
  (let* ((monday (encode-time 0 0 9 6 1 2025))
         (result (org-gantt-time-change-workdays monday 4 #'time-add test-work-free-days))
         (decoded (decode-time result)))
    (should (= 10 (nth 3 decoded)))  ; Friday the 10th
    (should (= 5 (string-to-number (format-time-string "%w" result))))))  ; Friday = 5

(ert-deftest org-gantt-time-test-change-workdays-skip-weekend ()
  "Test that adding workdays skips weekends."
  ;; Start on Friday Jan 10, add 1 workday = Monday Jan 13
  (let* ((friday (encode-time 0 0 9 10 1 2025))
         (result (org-gantt-time-change-workdays friday 1 #'time-add test-work-free-days))
         (decoded (decode-time result)))
    (should (= 13 (nth 3 decoded)))  ; Monday the 13th
    (should (= 1 (string-to-number (format-time-string "%w" result))))))  ; Monday = 1

;;; Time Arithmetic Tests

(ert-deftest org-gantt-time-test-add-worktime-same-day ()
  "Test adding work time within same day."
  ;; Start at 9 AM Monday, add 2 hours = 11 AM Monday
  (let* ((start (encode-time 0 0 9 6 1 2025))
         (change (seconds-to-time (* 2 3600)))  ; 2 hours
         (result (org-gantt-time-add-worktime start change 8 test-work-free-days))
         (decoded (decode-time result)))
    (should (= 11 (nth 2 decoded)))  ; 11 AM
    (should (= 6 (nth 3 decoded)))))  ; same day

(ert-deftest org-gantt-time-test-add-worktime-cross-day ()
  "Test adding work time that crosses to next day."
  ;; Start at 6 AM (6 hours into 8-hour day), add 4 hours
  ;; Should end at 2 hours into next day
  (let* ((start (encode-time 0 0 6 6 1 2025))
         (change (seconds-to-time (* 4 3600)))  ; 4 hours
         (result (org-gantt-time-add-worktime start change 8 test-work-free-days))
         (decoded (decode-time result)))
    (should (= 7 (nth 3 decoded)))  ; Next day (Tuesday)
    (should (= 2 (nth 2 decoded)))))  ; 2 hours into day

(ert-deftest org-gantt-time-test-add-worktime-cross-weekend ()
  "Test adding work time that spans weekend."
  ;; Start Friday at 6 AM, add 4 hours = Monday 2 AM
  (let* ((friday (encode-time 0 0 6 10 1 2025))  ; Friday Jan 10
         (change (seconds-to-time (* 4 3600)))  ; 4 hours
         (result (org-gantt-time-add-worktime friday change 8 test-work-free-days))
         (dow (string-to-number (format-time-string "%w" result))))
    ;; Should land on Monday
    (should (= 1 dow))))

(ert-deftest org-gantt-time-test-add-worktime-multiple-days ()
  "Test adding work time spanning multiple days."
  ;; Start Monday 9 AM, add 20 hours of work (2.5 days at 8h/day)
  (let* ((monday (encode-time 0 0 0 6 1 2025))  ; Monday midnight
         (change (seconds-to-time (* 20 3600)))  ; 20 hours
         (result (org-gantt-time-add-worktime monday change 8 test-work-free-days))
         (decoded (decode-time result)))
    ;; 20 hours = 2 full days + 4 hours
    ;; Monday 8h -> Tuesday 8h -> Wednesday 4h
    (should (= 8 (nth 3 decoded)))  ; Wednesday Jan 8
    (should (= 4 (nth 2 decoded)))))  ; 4 hours into day

;;; Time Normalization Tests

(ert-deftest org-gantt-time-test-downcast-end-midnight ()
  "Test downcasting midnight to previous day end."
  ;; Midnight should become hours-per-day of previous day
  (let* ((midnight (encode-time 0 0 0 7 1 2025))  ; Midnight Jan 7
         (result (org-gantt-time-downcast-end midnight 8 test-work-free-days))
         (decoded (decode-time result)))
    (should (= 6 (nth 3 decoded)))  ; Previous day
    (should (= 8 (nth 2 decoded)))))  ; 8 AM (hours-per-day)

(ert-deftest org-gantt-time-test-downcast-end-normal ()
  "Test that non-midnight times are unchanged."
  (let* ((time (encode-time 0 30 14 7 1 2025))  ; 2:30 PM
         (result (org-gantt-time-downcast-end time 8 test-work-free-days)))
    (should (time-equal-p time result))))

(ert-deftest org-gantt-time-test-upcast-start-end-of-day ()
  "Test upcasting end-of-day to next day start."
  ;; 8 AM (hours-per-day) should become midnight next day
  (let* ((day-end (encode-time 0 0 8 6 1 2025))  ; 8 AM Jan 6
         (result (org-gantt-time-upcast-start day-end 8 test-work-free-days))
         (decoded (decode-time result)))
    (should (= 7 (nth 3 decoded)))  ; Next day
    (should (= 0 (nth 2 decoded)))))  ; Midnight

;;; Ratio Calculation Tests

(ert-deftest org-gantt-time-test-day-ratio ()
  "Test calculating day ratio."
  ;; 4 hours into 8-hour day = 0.5
  (let ((time (encode-time 0 0 4 6 1 2025)))
    (should (= 0.5 (org-gantt-time-day-ratio time 8))))
  ;; 2 hours into 8-hour day = 0.25
  (let ((time (encode-time 0 0 2 6 1 2025)))
    (should (= 0.25 (org-gantt-time-day-ratio time 8))))
  ;; nil time = 0
  (should (= 0 (org-gantt-time-day-ratio nil 8))))

(ert-deftest org-gantt-time-test-month-ratio ()
  "Test calculating month ratio."
  ;; Day 15 of 31-day month = ~0.48
  (let ((time (encode-time 0 0 12 15 1 2025)))  ; Jan has 31 days
    (should (< 0.48 (org-gantt-time-month-ratio time)))
    (should (> 0.49 (org-gantt-time-month-ratio time))))
  ;; nil time = 0
  (should (= 0 (org-gantt-time-month-ratio nil))))

;;; org-gantt-time-test.el ends here
#+end_src

* Success Criteria

- [ ] =org-gantt-time.el= exists with 15+ functions
- [ ] No function accesses global state
- [ ] All functions accept configuration as parameters
- [ ] File byte-compiles without warnings
- [ ] All 20+ time tests pass
- [ ] Compatibility wrappers exist in =org-gantt.el=
- [ ] Regression test passes

* Next Phase

Once all criteria pass, proceed to [[file:06-phase-parse.org][Phase 5: Extract Parse Module]].
